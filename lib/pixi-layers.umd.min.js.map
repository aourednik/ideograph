{"version":3,"file":"pixi-layers.umd.min.js","sources":["../src/DisplayMixin.ts","../src/RendererMixin.ts","../src/Group.ts","../src/Stage.ts","../src/index.ts"],"sourcesContent":["import { DisplayObject, Container } from '@pixi/display';\r\n\r\n/** @ignore */\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function generateLayerContainerRenderMethod(originalRender: any)\r\n{\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    return function render(renderer: any): void\r\n    {\r\n        if (this._activeParentLayer && this._activeParentLayer !== renderer._activeLayer)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (!this.visible)\r\n        {\r\n            this.displayOrder = 0;\r\n\r\n            return;\r\n        }\r\n\r\n        this.displayOrder = renderer.incDisplayOrder();\r\n\r\n        // if the object is not visible or the alpha is 0 then no need to render this element\r\n        if (this.worldAlpha <= 0 || !this.renderable)\r\n        {\r\n            return;\r\n        }\r\n\r\n        renderer._activeLayer = null;\r\n        originalRender.call(this, renderer);\r\n        renderer._activeLayer = this._activeParentLayer;\r\n    };\r\n}\r\n\r\n// special case - container render method, because we want it to be faster\r\n/**\r\n * @internal\r\n * @private\r\n * @ignore\r\n */\r\nfunction containerRender(renderer: any): void\r\n{\r\n    if (this._activeParentLayer && this._activeParentLayer !== renderer._activeLayer)\r\n    {\r\n        return;\r\n    }\r\n\r\n    if (!this.visible)\r\n    {\r\n        this.displayOrder = 0;\r\n\r\n        return;\r\n    }\r\n\r\n    this.displayOrder = renderer.incDisplayOrder();\r\n\r\n    // if the object is not visible or the alpha is 0 then no need to render this element\r\n    if (this.worldAlpha <= 0 || !this.renderable)\r\n    {\r\n        return;\r\n    }\r\n\r\n    renderer._activeLayer = null;\r\n    this.containerRenderWebGL(renderer);\r\n    renderer._activeLayer = this._activeParentLayer;\r\n}\r\n\r\nexport function applyDisplayMixin(): void\r\n{\r\n    if (DisplayObject.prototype.displayOrder !== undefined)\r\n    {\r\n        return;\r\n    }\r\n\r\n    (Object as any).assign(DisplayObject.prototype, {\r\n        parentLayer: null,\r\n        _activeParentLayer: null,\r\n        parentGroup: null,\r\n        zOrder: 0,\r\n        zIndex: 0,\r\n        updateOrder: 0,\r\n        displayOrder: 0,\r\n        layerableChildren: true,\r\n        isLayer: false\r\n    });\r\n\r\n    const ContainerProto = Container.prototype as any;\r\n\r\n    ContainerProto.containerRenderWebGL = ContainerProto.render;\r\n    ContainerProto.render = containerRender;\r\n}\r\n\r\n/** Apply mixin to your custom Container class (not needed if using built-in {@link PIXI.Container}) */\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function applyContainerRenderMixin(CustomRenderContainer: any): void\r\n{\r\n    if (CustomRenderContainer.originalRenderWebGL)\r\n    {\r\n        return;\r\n    }\r\n\r\n    CustomRenderContainer.originalRenderWebGL = CustomRenderContainer.render;\r\n    CustomRenderContainer.render = generateLayerContainerRenderMethod(CustomRenderContainer.render);\r\n\r\n    if (CustomRenderContainer.renderCanvas)\r\n    {\r\n        CustomRenderContainer.originalRenderWebGL = CustomRenderContainer.renderCanvas;\r\n        CustomRenderContainer.renderCanvas = generateLayerContainerRenderMethod(CustomRenderContainer.renderCanvas);\r\n    }\r\n}\r\n\r\n/** Apply mixin for particles */\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function applyParticleMixin(ParticleContainer: any): void\r\n{\r\n    ParticleContainer.prototype.layerableChildren = false;\r\n    this.applyRenderMixing(ParticleContainer);\r\n}\r\n","import { IRenderableObject, IRendererRenderOptions, Renderer } from '@pixi/core';\r\nimport { Container } from '@pixi/display';\r\nimport { LayersTreeSearch } from './LayersTreeSearch';\r\nimport { generateLayerContainerRenderMethod } from './DisplayMixin';\r\n\r\nimport type { Stage } from './Stage';\r\nimport type { Layer } from './Layer';\r\n\r\n/**\r\n * Mixin applied on {@link PIXI.Renderer} when using @pixi/layers.\r\n */\r\nexport interface ILayeredRenderer\r\n{\r\n    /** Order/index of last rendered object */\r\n    _lastDisplayOrder: number;\r\n\r\n    /** {@link Layer} currently being rendered */\r\n    _activeLayer: Layer;\r\n\r\n    /** **Internal** method for updating {@link ILayeredRenderer#_lastDisplayOrder} */\r\n    incDisplayOrder(): number;\r\n\r\n    /** **Internal** reference to old render method */\r\n    _oldRender(displayObject: IRenderableObject, options?: IRendererRenderOptions): void;\r\n}\r\n\r\n/**\r\n * @internal\r\n * @ignore\r\n */\r\nfunction generateLayerRendererMethod(_oldRender: any)\r\n{\r\n    return function render(displayObject: IRenderableObject, options: any, arg1?: any, arg2?: any, arg3?: any)\r\n    {\r\n        if (!options || (!options.renderTexture && !options.baseTexture))\r\n        {\r\n            this._lastDisplayOrder = 0;\r\n        }\r\n        this._activeLayer = null;\r\n\r\n        if ((displayObject as Stage).isStage)\r\n        {\r\n            (displayObject as Stage).updateStage();\r\n        }\r\n        if (this.plugins.interaction && !this.plugins.interaction.search.worksWithLayers)\r\n        {\r\n            this.plugins.interaction.search = new LayersTreeSearch();\r\n        }\r\n\r\n        _oldRender.call(this, displayObject, options, arg1, arg2, arg3);\r\n    };\r\n}\r\n\r\n/**\r\n * Mixes {@link ILayeredRenderer} into {@link PIXI.Renderer}.\r\n *\r\n * This is automatically done on importing @pixi/layers.\r\n */\r\nexport function applyRendererMixin(rendererClass: typeof Renderer): void\r\n{\r\n    const RendererProto = rendererClass.prototype as (Renderer & Partial<ILayeredRenderer>);\r\n\r\n    // Skip if mixin already applied.\r\n    if (RendererProto._oldRender)\r\n    {\r\n        return;\r\n    }\r\n\r\n    Object.assign(RendererProto, {\r\n        _lastDisplayOrder: 0,\r\n        _activeLayer: null,\r\n        incDisplayOrder()\r\n        {\r\n            return ++this._lastDisplayOrder;\r\n        },\r\n        _oldRender: Renderer.prototype.render,\r\n    });\r\n\r\n    RendererProto._oldRender = RendererProto.render;\r\n    RendererProto.render = generateLayerRendererMethod(RendererProto.render);\r\n}\r\n\r\n/**\r\n * Mixes renderer mixin + container mixin for canvas.\r\n *\r\n * If you are using PixiJS' canvas renderer, you'll need to invoke this manually.\r\n *\r\n * @example\r\n * import { CanvasRenderer } from '@pixi/canvas-renderer';\r\n * import { applyCanvasMixin } from '@pixi/layers';\r\n *\r\n * applyCanvasMixin(CanvasRenderer);\r\n */\r\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\nexport function applyCanvasMixin(canvasRenderClass: any): void\r\n{\r\n    if (!canvasRenderClass)\r\n    {\r\n        // eslint-disable-next-line max-len,no-console\r\n        console.log('@pixi/layers: Canvas mixin was called with empty parameter. Are you sure that you even need this line?');\r\n\r\n        return;\r\n    }\r\n\r\n    applyRendererMixin(canvasRenderClass);\r\n\r\n    const ContainerProto = Container.prototype as any;\r\n\r\n    if (ContainerProto.containerRenderCanvas)\r\n    {\r\n        return;\r\n    }\r\n\r\n    ContainerProto.containerRenderCanvas = ContainerProto.renderCanvas;\r\n    ContainerProto.renderCanvas = generateLayerContainerRenderMethod(ContainerProto.renderCanvas);\r\n}\r\n\r\n","import * as utils from '@pixi/utils';\r\n\r\nimport type { DisplayObject } from '@pixi/display';\r\nimport type { Layer } from './Layer';\r\nimport type { Stage } from './Stage';\r\n\r\n/**\r\n * A context for z-ordering {@link PIXI.DisplayObject}s within the same {@link Layer}.\r\n */\r\nexport class Group extends utils.EventEmitter\r\n{\r\n    static _layerUpdateId = 0;\r\n\r\n    /** See {@link Layer#useRenderTexture} */\r\n    public useRenderTexture = false;\r\n\r\n    /** See {@link Layer#useDoubleBuffer} */\r\n    public useDoubleBuffer = false;\r\n\r\n    /**\r\n     * Groups with a non-zero sort priority are sorted first.\r\n     *\r\n     * Unsure of the exact purpose yet :)\r\n     */\r\n    public sortPriority = 0;\r\n\r\n    /** See {@link Layer#clearColor} */\r\n    public clearColor : ArrayLike<number> = new Float32Array([0, 0, 0, 0]);\r\n\r\n    // TODO: handle orphan groups\r\n    // TODO: handle groups that don't want to be drawn in parent\r\n    canDrawWithoutLayer = false;\r\n    canDrawInParentStage = true;\r\n\r\n    /** Default zIndex value for layers that are created with this Group */\r\n    public zIndex: number;\r\n\r\n    /** Enabling sorting objects within this group by {@link PIXI.DisplayObject#zOrder zOrder}. */\r\n    public enableSort: boolean;\r\n\r\n    private _activeLayer: Layer = null;\r\n    private _activeStage: Stage = null;\r\n    /** @private */\r\n    _activeChildren: Array<DisplayObject> = [];\r\n    private _lastUpdateId = -1;\r\n\r\n    /**\r\n     * @param zIndex - The z-index for the entire group.\r\n     * @param sorting - This will enable sorting by z-order. You can also pass a callback that will assign\r\n     *  the z-index _before_ sorting. This is useful, for example, when you want to sort by \"y\" - the callback\r\n     *  can then set the {@link PIXI.DisplayObject#zOrder zOrder} to the y-coordinate. This callback is invoked\r\n     *  as an event-listener to the {@link Group#sort} event.\r\n     */\r\n    constructor(zIndex = 0, sorting: boolean | ((displayObject: DisplayObject) => void) = false)\r\n    {\r\n        super();\r\n\r\n        this.zIndex = zIndex || 0;\r\n        this.enableSort = !!sorting;\r\n\r\n        if (typeof sorting === 'function')\r\n        {\r\n            this.on('sort', sorting);\r\n        }\r\n    }\r\n\r\n    doSort(layer: Layer, sorted: Array<DisplayObject>): void\r\n    {\r\n        if ((this.listeners as any)('sort', true))\r\n        {\r\n            for (let i = 0; i < sorted.length; i++)\r\n            {\r\n                this.emit('sort', sorted[i]);\r\n            }\r\n        }\r\n\r\n        sorted.sort(Group.compareZIndex);\r\n    }\r\n\r\n    private static compareZIndex(a: DisplayObject, b: DisplayObject): number\r\n    {\r\n        if (a.zOrder < b.zOrder)\r\n        {\r\n            return -1;\r\n        }\r\n        if (a.zOrder > b.zOrder)\r\n        {\r\n            return 1;\r\n        }\r\n\r\n        return a.updateOrder - b.updateOrder;\r\n    }\r\n\r\n    /**\r\n     * clears temporary variables\r\n     */\r\n    private clear(): void\r\n    {\r\n        this._activeLayer = null;\r\n        this._activeStage = null;\r\n        this._activeChildren.length = 0;\r\n    }\r\n\r\n    /**\r\n     * Resolve a child {@link PIXI.DisplayObject} that is set to be in this group.\r\n     *\r\n     * This is an **internal** method.\r\n     *\r\n     * @see Stage#updateStage\r\n     */\r\n    _resolveChildDisplayObject(stage: Stage, displayObject: DisplayObject): void\r\n    {\r\n        this.check(stage);\r\n        displayObject._activeParentLayer = this._activeLayer;\r\n\r\n        if (this._activeLayer)\r\n        {\r\n            this._activeLayer._activeChildren.push(displayObject);\r\n        }\r\n        else\r\n        {\r\n            this._activeChildren.push(displayObject);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resolve the layer rendering this group of {@link DisplayObject display objects}.\r\n     *\r\n     * This is an **internal** method.\r\n     *\r\n     * @see Layer#_onBeginLayerSubtreeTraversal\r\n     */\r\n    _resolveLayer(stage: Stage, layer: Layer): void\r\n    {\r\n        this.check(stage);\r\n\r\n        if (this._activeLayer)\r\n        {\r\n            Group.conflict();\r\n        }\r\n\r\n        this._activeLayer = layer;\r\n        this._activeStage = stage;\r\n    }\r\n\r\n    private check(stage: Stage): void\r\n    {\r\n        if (this._lastUpdateId < Group._layerUpdateId)\r\n        {\r\n            this._lastUpdateId = Group._layerUpdateId;\r\n            this.clear();\r\n            this._activeStage = stage;\r\n        }\r\n        else if (this.canDrawInParentStage)\r\n        {\r\n            let current = this._activeStage;\r\n\r\n            while (current && current !== stage)\r\n            {\r\n                current = current._activeParentStage;\r\n            }\r\n            this._activeStage = current;\r\n            if (current === null)\r\n            {\r\n                this.clear();\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _lastLayerConflict = 0;\r\n\r\n    /** Log a conflict that occurs when multiple layers render the same group. */\r\n    private static conflict(): void\r\n    {\r\n        if (Group._lastLayerConflict + 5000 < Date.now())\r\n        {\r\n            Group._lastLayerConflict = Date.now();\r\n            // eslint-disable-next-line max-len,no-console\r\n            console.log(`@pixi/layers found two layers with the same group in one stage - that's not healthy. Please place a breakpoint here and debug it`);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Fired for each {@link DisplayObject} in this group, right before they are sorted.\r\n     *\r\n     * @event sort\r\n     * @param {PIXI.DisplayObject} object - The object that will be sorted.\r\n     */\r\n}\r\n","import { Container, DisplayObject } from '@pixi/display';\r\nimport { Layer } from './Layer';\r\nimport { Group } from './Group';\r\n\r\n/**\r\n * The {@link Stage stage} manages all the layers in its scene tree.\r\n *\r\n *\r\n */\r\nexport class Stage extends Layer\r\n{\r\n    static _updateOrderCounter = 0;\r\n\r\n    /** Flags that this is a {@link Stage stage}! */\r\n    public readonly isStage = true;\r\n\r\n    _tempGroups: Array<DisplayObject> = [];\r\n\r\n    /**\r\n     * Found layers\r\n     */\r\n    _activeLayers: Array<Layer> = [];\r\n\r\n    _activeParentStage: Stage = null;\r\n\r\n    /**\r\n     * clears all display lists that were used in last rendering session\r\n     * please clear it when you stop using this displayList, otherwise you may have problems with GC in some cases\r\n     */\r\n    clear(): void\r\n    {\r\n        this._activeLayers.length = 0;\r\n        this._tempGroups.length = 0;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n    destroy(options?: any): void\r\n    {\r\n        this.clear();\r\n        super.destroy(options);\r\n    }\r\n\r\n    /**\r\n     * This should be called before rendering for resolving items in the scene tree to their {@link Layer layers}.\r\n     *\r\n     * If your scene's root is a {@link Stage}, then the {@link ILayerRenderer} mixin will automatically\r\n     * call it.\r\n     */\r\n    updateStage(): void\r\n    {\r\n        this._activeParentStage = null;\r\n        Group._layerUpdateId++;\r\n        this._updateStageInner();\r\n    }\r\n\r\n    private updateAsChildStage(stage: Stage): void\r\n    {\r\n        this._activeParentStage = stage;\r\n        Stage._updateOrderCounter = 0;\r\n        this._updateStageInner();\r\n    }\r\n\r\n    private _updateStageInner(): void\r\n    {\r\n        this.clear();\r\n        this._addRecursive(this);\r\n        const layers = this._activeLayers;\r\n\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            const layer = layers[i];\r\n\r\n            if (layer.group.sortPriority)\r\n            {\r\n                layer._onEndLayerSubtreeTraversal();\r\n                const sorted = layer._sortedChildren;\r\n\r\n                for (let j = 0; j < sorted.length; j++)\r\n                {\r\n                    this._addRecursiveChildren(sorted[j]);\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < layers.length; i++)\r\n        {\r\n            const layer = layers[i];\r\n\r\n            if (!layer.group.sortPriority)\r\n            {\r\n                layer._onEndLayerSubtreeTraversal();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addRecursive(displayObject: DisplayObject): void\r\n    {\r\n        if (!displayObject.visible)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if ((displayObject as any).isLayer)\r\n        {\r\n            const layer = displayObject as any as Layer;\r\n\r\n            this._activeLayers.push(layer);\r\n            layer._onBeginLayerSubtreeTraversal(this);\r\n        }\r\n\r\n        if (displayObject !== this && (displayObject as any).isStage)\r\n        {\r\n            const stage = displayObject as Stage;\r\n\r\n            stage.updateAsChildStage(this);\r\n\r\n            return;\r\n        }\r\n\r\n        displayObject._activeParentLayer = null;\r\n        let group = displayObject.parentGroup;\r\n\r\n        if (group)\r\n        {\r\n            group._resolveChildDisplayObject(this, displayObject);\r\n        }\r\n        const layer = displayObject.parentLayer;\r\n\r\n        if (layer)\r\n        {\r\n            group = layer.group;\r\n            group._resolveChildDisplayObject(this, displayObject);\r\n        }\r\n\r\n        displayObject.updateOrder = ++Stage._updateOrderCounter;\r\n        if (displayObject.alpha <= 0 || !displayObject.renderable\r\n            || !displayObject.layerableChildren\r\n            || (group && group.sortPriority))\r\n        {\r\n            return;\r\n        }\r\n\r\n        const children = (displayObject as Container).children;\r\n\r\n        if (children && children.length)\r\n        {\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                this._addRecursive(children[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _addRecursiveChildren(displayObject: DisplayObject): void\r\n    {\r\n        if (displayObject.alpha <= 0 || !displayObject.renderable\r\n            || !displayObject.layerableChildren)\r\n        {\r\n            return;\r\n        }\r\n        const children = (displayObject as Container).children;\r\n\r\n        if (children && children.length)\r\n        {\r\n            for (let i = 0; i < children.length; i++)\r\n            {\r\n                this._addRecursive(children[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n","/* eslint-disable spaced-comment */\r\n/// <reference path=\"../global.d.ts\" />\r\n\r\nimport { applyDisplayMixin, applyContainerRenderMixin, applyParticleMixin } from './DisplayMixin';\r\nimport { applyRendererMixin, applyCanvasMixin, ILayeredRenderer } from './RendererMixin';\r\nimport { Renderer } from '@pixi/core';\r\n\r\nexport * from './Stage';\r\nexport * from './Layer';\r\nexport * from './Group';\r\n\r\nexport { applyDisplayMixin, applyCanvasMixin, applyContainerRenderMixin, applyRendererMixin, applyParticleMixin };\r\nexport { ILayeredRenderer };\r\n\r\napplyDisplayMixin();\r\napplyRendererMixin(Renderer);\r\n\r\n/**\r\n * The {@link Group group} in which this display object should be rendered.\r\n *\r\n * This is provided by **@pixi/layers**.\r\n *\r\n * @memberof PIXI.DisplayObject\r\n * @member {Group}\r\n * @name parentGroup\r\n */\r\n\r\n/**\r\n * The {@link Layer layer} in which this display object should be rendered; don't set this if you're\r\n * using {@link PIXI.DisplayObject#parentLayer}.\r\n *\r\n * This is provided by **@pixi/layers**.\r\n *\r\n * @memberof PIXI.DisplayObject\r\n * @member {Layer}\r\n * @name parentLayer\r\n */\r\n\r\n/**\r\n * Objects in a {@link Group group} are sorted by z-order.\r\n * This can be used alongside PixiJS' built-in {@link PIXI.DisplayObject#zIndex zIndex}.\r\n *\r\n * If you use both {@code zIndex} and {@code zOrder}, objects will first be sorted by z-index\r\n * and then @pixi/layers will sort by z-order.\r\n *\r\n * This is provided by **@pixi/layers**.\r\n *\r\n * @memberof PIXI.DisplayObject\r\n * @member {number}\r\n * @name zOrder\r\n */\r\n"],"names":["Group","Stage","applyDisplayMixin","applyRendererMixin"],"mappings":";inCAyCA,qoECXA,s6DCnBWA,mBA8JQA,6uNC9JRC,wBCGXC,IACAC"}